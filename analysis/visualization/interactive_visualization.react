import React,

{useState}
from

'react';
import

{ArrowRight, ArrowLeft}
from

'lucide-react';

const
TransformerVisualization = () = > {
                                  // State
for visualization parameters
const[trainingPhase, setTrainingPhase] = useState('early'); // early, middle, late
const[showCircuits, setShowCircuits] = useState(true);
const[showMLPActivity, setShowMLPActivity] = useState(true);
const[showHeadAttribution, setShowHeadAttribution] = useState(true);

// Model configuration
const numLayers = 2;
const numHeads = 4;
const seqLength = 5;

// Simulated data based on your research
// This would be replaced with actual data from your analyzers
const modelData = {
early: {
    attentionPatterns: [
                           [0.2, 0.1, 0.3, 0.2], // Layer 0 heads
                                                            [0.1, 0.2, 0.1, 0.1] // Layer 1 heads
],
mlpActivations: [0.1, 0.2],
headAttributions: [
                      [0.1, 0.3, 0.2, 0.1], // Layer
0
heads
[0.1, 0.1, 0.2, 0.1] // Layer
1
heads
],
circuits: [
          // format: [source_layer, source_head, target_layer, target_head, strength]
[0, 1, 1, 2, 0.2]
]
},
middle: {
    attentionPatterns: [
                           [0.5, 0.7, 0.4, 0.3], // Layer 0 heads
                                                            [0.3, 0.5, 0.6, 0.3] // Layer 1 heads
],
mlpActivations: [0.5, 0.6],
headAttributions: [
                      [0.3, 0.7, 0.4, 0.2], // Layer
0
heads
[0.2, 0.3, 0.7, 0.4] // Layer
1
heads
],
circuits: [
          // format: [source_layer, source_head, target_layer, target_head, strength]
[0, 1, 1, 2, 0.6],
[0, 2, 1, 0, 0.4]
]
},
late: {
    attentionPatterns: [
                           [0.6, 0.9, 0.5, 0.4], // Layer 0 heads
                                                            [0.4, 0.5, 0.9, 0.7] // Layer 1 heads
],
mlpActivations: [0.8, 0.9],
headAttributions: [
                      [0.4, 0.9, 0.5, 0.3], // Layer
0
heads
[0.3, 0.4, 0.9, 0.7] // Layer
1
heads
],
circuits: [
          // format: [source_layer, source_head, target_layer, target_head, strength]
[0, 1, 1, 2, 0.9],
[0, 2, 1, 0, 0.7],
[0, 0, 1, 3, 0.5]
]
}
};

const
data = modelData[trainingPhase];

// Helper
functions
const
getIntensityColor = (value, baseColor = '0, 0, 255') = > {
    const
alpha = Math.max(0.1, Math.min(0.9, value));
return `rgba(${baseColor}, ${alpha})`;
};

const
getHeadColor = (layerIdx, headIdx) = > {
const
attribution = data.headAttributions[layerIdx][headIdx];
return getIntensityColor(attribution, '0, 0, 255');
};

const
getMLPColor = (layerIdx) = > {
const
activation = data.mlpActivations[layerIdx];
return getIntensityColor(activation, '0, 128, 0');
};

const
getCircuitColor = (strength) = > {
return getIntensityColor(strength, '255, 0, 0');
};

const
CircuitConnector = ({ from, to, strength}) = > {
const
path = `M${
from .x} ${
from .y} C ${
from .x

+ 50} ${
from .y}, ${to.x - 50} ${to.y}, ${to.x} ${to.y}
`;

return (
    < path
    d={path}
    stroke={getCircuitColor(strength)}
strokeWidth = {Math.max(1, strength * 5)}
fill = "none"
strokeDasharray = "5,5"
                  / >
);
};

const
AttentionHead = ({layerIdx, headIdx, x, y}) = > {
const
attribution = data.headAttributions[layerIdx][headIdx];
const
size = Math.max(30, attribution * 50);

return (
    < g >
    < circle
    cx={x}
    cy={y}
    r={size / 2}
    fill={getHeadColor(layerIdx, headIdx)}
stroke = "#333"
strokeWidth = "1"
              / >
              < text
x = {x}
y = {y}
textAnchor = "middle"
dominantBaseline = "middle"
fill = "white"
fontSize = "12px"
           >
           {headIdx}
           < / text >
               < / g >
);
};

const
MLPBlock = ({layerIdx, x, y, width, height}) = > {
return (
    < rect
    x={x - width / 2}
    y={y - height / 2}
    width={width}
    height={height}
    fill={getMLPColor(layerIdx)}
stroke = "#333"
strokeWidth = "1"
rx = "5"
ry = "5"
     / >
);
};

const
InputEmbedding = ({x, y}) = > {
return (
    < g >
    < rect
    x={x - 75}
    y={y - 25}
    width={150}
    height={50}
    fill="#ddd"
    stroke="#333"
    strokeWidth="1"
    rx="5"
    ry="5"
    / >
    < text
    x={x}
    y={y}
    textAnchor="middle"
    dominantBaseline="middle"
    fontSize="12px"
    >
    Input Embedding
    < / text >
    < / g >
);
};

const
Output = ({x, y}) = > {
return (
    < g >
    < rect
    x={x - 75}
    y={y - 25}
    width={150}
    height={50}
    fill="#ddd"
    stroke="#333"
    strokeWidth="1"
    rx="5"
    ry="5"
    / >
    < text
    x={x}
    y={y}
    textAnchor="middle"
    dominantBaseline="middle"
    fontSize="12px"
    >
    Output
    < / text >
    < / g >
);
};

const
ResidualConnection = ({ from, to}) = > {
// Create
a
path
that
bypasses
the
main
flow
const
path = `M${
from .x

+ 100} ${
from .y} L${to.x + 100} ${to.y}
`;

return (
    < g >
    < path
    d={path}
    stroke="#aaa"
    strokeWidth="2"
    fill="none"
    / >
    < ArrowRight color="#aaa" size={16} style={{transform: `translate(${to.x + 92}px, ${to.y - 8}px)
`}} / >
< / g >
);
};

const
TrainingPhaseControls = () = > (
< div
className = "flex flex-col space-y-4 p-4 bg-gray-100 rounded-lg" >
< div >
< h3
className = "font-bold mb-2" > Training
Phase < / h3 >
< div
className = "flex space-x-2" >
< button
onClick = {() = > setTrainingPhase('early')}
className = {`px - 4
py - 2
rounded ${trainingPhase == = 'early' ? 'bg-blue-500 text-white': 'bg-gray-200'}`}
>
Early
< / button >
< button
onClick = {() = > setTrainingPhase('middle')}
className = {`px - 4
py - 2
rounded ${trainingPhase == = 'middle' ? 'bg-blue-500 text-white': 'bg-gray-200'}`}
>
Middle
< / button >
< button
onClick = {() = > setTrainingPhase('late')}
className = {`px - 4
py - 2
rounded ${trainingPhase == = 'late' ? 'bg-blue-500 text-white': 'bg-gray-200'}`}
>
Late
< / button >
< / div >
< / div >

< div >
< h3
className = "font-bold mb-2" > Display
Options < / h3 >
< div
className = "flex flex-col space-y-2" >
< label
className = "flex items-center space-x-2" >
< input
type = "checkbox"
checked = {showCircuits}
onChange = {() = > setShowCircuits(!showCircuits)}
className = "form-checkbox h-5 w-5 text-blue-600"
/ >
< span > Show
Circuits < / span >
< / label >
< label
className = "flex items-center space-x-2" >
< input
type = "checkbox"
checked = {showMLPActivity}
onChange = {() = > setShowMLPActivity(!showMLPActivity)}
className = "form-checkbox h-5 w-5 text-blue-600"
/ >
< span > Show
MLP
Activity < / span >
< / label >
< label
className = "flex items-center space-x-2" >
< input
type = "checkbox"
checked = {showHeadAttribution}
onChange = {() = > setShowHeadAttribution(!showHeadAttribution)}
className = "form-checkbox h-5 w-5 text-blue-600"
/ >
< span > Show
Head
Attribution < / span >
< / label >
< / div >
< / div >

< div
className = "mt-4 p-2 bg-yellow-100 rounded text-sm" >
< p > < strong > Legend: < / strong > < / p >
< div
className = "flex items-center mt-1" >
< div
className = "w-4 h-4 bg-blue-500 rounded mr-2" > < / div >
< span > Attention
Head(intensity=attribution) < / span >
< / div >
< div
className = "flex items-center mt-1" >
< div
className = "w-4 h-4 bg-green-500 rounded mr-2" > < / div >
< span > MLP
Activity < / span >
< / div >
< div
className = "flex items-center mt-1" >
< div
className = "w-4 h-4 bg-red-500 rounded mr-2" > < / div >
< span > Circuit
Connection < / span >
< / div >
< div
className = "flex items-center mt-1" >
< div
className = "w-8 h-1 bg-gray-400 rounded mr-2" > < / div >
< span > Residual
Connection < / span >
< / div >
< / div >
< / div >
);

// Calculate
positions
for the visualization
const svgWidth = 800;
const svgHeight = 500;
const layerMargin = 150;
const headSpacing = 60;
const layerHeight = numHeads * headSpacing + 100;

// Calculate head positions and track them for drawing circuits
const headPositions = {};

return (
    < div className="flex flex-col md:flex-row" >
    < div className="md:w-2/3" >
    < h2 className="text-xl font-bold mb-4" > Transformer Architecture Visualization - {trainingPhase.charAt(0).toUpperCase() + trainingPhase.slice(
    1)} Training < / h2 >
                     < svg
width = {svgWidth}
height = {svgHeight}
viewBox = {`0
0 ${svgWidth} ${svgHeight}
`} >
{ / * Input
Embedding * /}
< InputEmbedding
x = {100}
y = {svgHeight / 2} / >

    { / * Draw
each
layer * /}
{Array.
from

({length: numLayers}).map((_, layerIdx) = > {
    const
layerX = 250 + layerIdx * layerMargin;
const
layerCenterY = svgHeight / 2;

return (
    < g key={`layer-${layerIdx}`} >
    {/ * Layer label * /}
    < text
    x={layerX}
    y={20}
    textAnchor="middle"
    fontSize="14px"
    fontWeight="bold"
    >
    Layer {layerIdx}
    < / text >

    {/ * Attention Heads * /}
    < g >
    < text
    x={layerX}
    y={50}
    textAnchor="middle"
    fontSize="12px"
    >
    Attention Heads
    < / text >

    {Array.from ({length: numHeads}).map((_, headIdx) = > {
    const
headY = 80 + headIdx * headSpacing;
// Store
position
for circuit connections
headPositions[`${layerIdx}-${headIdx}`] = {x: layerX, y: headY};

return (
    < AttentionHead
    key={`head-${layerIdx}-${headIdx}`}
    layerIdx={layerIdx}
    headIdx={headIdx}
    x={layerX}
    y={headY}
    / >
);
})}
< / g >

    { / * MLP
Block * /}
{showMLPActivity & & (
    < g >
    < text
    x={layerX}
    y={layerCenterY + 70}
    textAnchor="middle"
    fontSize="12px"
    >
    MLP
    < / text >
    < MLPBlock
    layerIdx={layerIdx}
    x={layerX}
    y={layerCenterY + 100}
    width={80}
    height={50}
    / >
    < / g >
)}

{ / * Data
flow
arrows * /}
< path
d = {`M${layerX - 50} ${layerCenterY}
L${layerX - 30} ${layerCenterY}
`}
stroke = "#333"
strokeWidth = "2"
markerEnd = "url(#arrowhead)"
fill = "none"
       / >

       {layerIdx < numLayers - 1 & & (
           < path
           d={`M${layerX + 50} ${layerCenterY} L${layerX + 100} ${layerCenterY}`}
           stroke="#333"
           strokeWidth="2"
           markerEnd="url(#arrowhead)"
           fill="none"
           / >
       )}

{ / * Residual
connections * /}
{layerIdx < numLayers - 1 & & (
    < ResidualConnection
    from ={{x: layerX - 50, y: layerCenterY}}
    to={{x: layerX + 100, y: layerCenterY}}
    / >
)}
< / g >
);
})}

{ / * Output * /}
< Output
x = {250 + (numLayers - 1) * layerMargin + 150}
y = {svgHeight / 2} / >

    { / * Circuits * /}
{showCircuits & & data.circuits.map((circuit, idx) = > {
    const[sourceLayer, sourceHead, targetLayer, targetHead, strength] = circuit;
const
sourceKey = `${sourceLayer} -${sourceHead}
`;
const
targetKey = `${targetLayer} -${targetHead}
`;

if (headPositions[sourceKey] & & headPositions[targetKey])
{
return (
    < CircuitConnector
    key={`circuit-${idx}`}
    from ={headPositions[sourceKey]}
    to={headPositions[targetKey]}
    strength={strength}
    / >
);
}
return null;
})}

{ / * Arrow
marker
definition * /}
< defs >
  < marker
id = "arrowhead"
markerWidth = "10"
markerHeight = "7"
refX = "0"
refY = "3.5"
orient = "auto"
         >
         < polygon
points = "0 0, 10 3.5, 0 7"
fill = "#333" / >
       < / marker >
           < / defs >
               < / svg >
                   < / div >

                       < div
className = "md:w-1/3" >
            < TrainingPhaseControls / >
            < / div >
                < / div >
);
};

export
default
TransformerVisualization;